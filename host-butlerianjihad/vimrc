if has('vim_starting')
  set nocompatible               " Be iMproved
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#begin(expand('~/.vim/bundle/'))

NeoBundleFetch 'Shougo/neobundle.vim'


" Run and manage child processes, dependency of many other plugins "{{{
NeoBundle 'Shougo/vimproc', {
      \ 'build' : {
      \     'windows' : 'make -f make_mingw32.mak',
      \     'cygwin' : 'make -f make_cygwin.mak',
      \     'mac' : 'make -f make_mac.mak',
      \     'unix' : 'make -f make_unix.mak',
      \    },
      \ }

" Ultimate UI system for running fuzzy-search on different things {{{
NeoBundle 'Shougo/unite.vim'
" Always start insert mode
let g:unite_enable_start_insert = 1
let g:unite_source_history_yank_enable = 1
let g:unite_split_rule = "botright"

" `ag` is a faster and better replacement for the standard `find`, let Unite use
" it if it exists and configure to properly use `.gitignore` or `.hgignore`
" files if those exist.
" To install `ag`: brew install ag
" or: https://github.com/ggreer/the_silver_searcher
if executable("ag")
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts = '--nogroup --nocolor --column'
  let g:unite_source_grep_recursive_opt = ''
endif

" Search settings
if exists("*unite")
  call unite#filters#matcher_default#use(['matcher_fuzzy'])
  call unite#filters#sorter_default#use(['sorter_rank'])
  call unite#set_profile('files', 'smartcase', 1)
endif
"}}}

NeoBundle "scrooloose/nerdtree"
"NERDTree toggle
nnoremap <silent> <Leader>t :NERDTreeToggle<CR>
NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'rking/ag.vim'
NeoBundle 'taiansu/nerdtree-ag'
NeoBundle 'Syntastic'
" Use jshint (uses ~/.jshintrc)
let g:syntastic_javascript_checkers = ['jshint','jscs']
" Use flake8 
let g:syntastic_python_checkers = ['flake8']

NeoBundle 'Tagbar'
"tagbar
nnoremap <silent> <Leader>] :TagbarToggle<CR>
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }


NeoBundle 'ctrlp/ctrlp.vim'
let g:ctrlp_map = '<c-p>'
set wildignore+=*/node_modules/*,*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux

let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn|node_modules)$'

NeoBundle 'tpope/vim-surround'
NeoBundle 'elzr/vim-json'
NeoBundle 'vim-ruby/vim-ruby'
NeoBundle 'pangloss/vim-javascript'
NeoBundle 'jelera/vim-javascript-syntax', {'autoload':{'filetypes':['javascript']}}
NeoBundle 'moll/vim-node'
NeoBundle 'kchmck/vim-coffee-script'
NeoBundle 'lukaszkorecki/CoffeeTags'
NeoBundle 'mxw/vim-jsx'

NeoBundle 'maksimr/vim-jsbeautify'
NeoBundle 'einars/js-beautify'
" JavaScript
let b:javascript_fold = 1
map <c-f> :call JsBeautify()<cr>
autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
autocmd FileType javascript setlocal ts=2 shiftwidth=2
autocmd FileType coffee setlocal ts=2 shiftwidth=2
" for html
autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>

NeoBundle 'marijnh/tern_for_vim'

NeoBundle 'klen/python-mode'
" pymode
let g:pymode_folding = 1
let g:pymode_indent = 1
let g:pymode_virtualenv = 1

NeoBundle 'fatih/vim-go'
NeoBundle 'nsf/gocode', {'rtp': 'vim/'}
NeoBundle 'yuratomo/dbg.vim'

NeoBundle 'derekwyatt/vim-scala'
NeoBundle 'tomlion/vim-solidity'

call neobundle#end()

if has('autocmd')
  filetype on
  filetype plugin indent on
  filetype detect
endif

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

"automatically change directory to current working file
autocmd BufEnter * silent! lcd %:p:h

"persist folds
autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview 

"markdown 
autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" set colorscheme
colorscheme elflord

"line numbers
set number

"columns
set ruler

"persistent undo
set undodir=~/.vim/undodir
set undofile
set undolevels =1000 "maximum number of changes that can be undone
set undoreload =10000 "maximum number lines to save for undo on a buffer reload

"indent settings
set backspace=indent,eol,start
set autoindent smartindent
set tabstop=2 shiftwidth=2 expandtab

"folding
set foldmethod=indent
set foldlevelstart=0
set foldlevel=0

"improved buffer switching
set wildchar=<Tab> wildmenu wildmode=full

"maps '' to copy to system clipboard, visual mode
:vmap '' :w !pbcopy<CR><CR>

"explicit paste toggle
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>
set showmode

"maps sv,ev to loading/opening vimrc
nmap <silent> ;sv :so $MYVIMRC<CR>
nmap <silent> ;ev :e $MYVIMRC<CR>

"leave insert mode quickly
inoremap jj <Esc>

"leave insert mode and save
inoremap jjw <Esc> :w<CR>

"leave insert mode, save, and quit
inoremap jjwq <Esc> :wq<CR>

"remap ex to Q for Ex-mode
nnoremap ex Q
"remap Q to q for recording
nnoremap Q q
"remap q to nop so that it can be safely reused
nnoremap q <Nop>
"remap qq for fast quit
nnoremap qq :q!<CR>

"faster split navigation
nmap <silent> <Up> :wincmd k<CR>
nmap <silent> <Down> :wincmd j<CR>
nmap <silent> <Left> :wincmd h<CR>
nmap <silent> <Right> :wincmd l<CR>

"ctags
set tags=./tags,./TAGS,tags;~,TAGS;~

syntax enable

" Automatically reload vimrc when it's saved "{{{
augroup VimrcSo
  au!
  autocmd BufWritePost $MYVIMRC so $MYVIMRC
augroup END
"}}}

function! DoPrettyXML()
  " save the filetype so we can restore it later
  let l:origft = &ft
  set ft=
  " delete the xml header if it exists. This will
  " permit us to surround the document with fake tags
  " without creating invalid xml.
  1s/<?xml .*?>//e
  " insert fake tags around the entire document.
  " This will permit us to pretty-format excerpts of
  " XML that may contain multiple top-level elements.
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  " xmllint will insert an <?xml?> header. it's easy enough to delete
  " if you don't want it.
  " delete the fake tags
  2d
  $d
  " restore the 'normal' indentation, which is one extra level
  " too deep due to the extra tags we wrapped around the document.
  silent %<
  " back to home
  1
  " restore the filetype
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()

